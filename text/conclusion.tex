\chapter{Conclusion}\label{chapter:conclusion}
%\label{future:fp}
%\label{future:intersection}
%\label{future:proofautomation}
%\label{future:continuations}
%\label{future:gradual}
%\label{future:errorreporting}
%\label{future:ghost}

We presented \toolname, an automatic, sound, and expressive verifier for Haskell code. 
%
We started (Chapter~\ref{chapter:tool}) by porting standard refinement types 
to Haskell to verify more than 10K lines of popular Haskell libraries. 
%
Then~(Chapter~\ref{chapter:refinedhaskell}), we observed that Haskell's 
lazy semantics render standard refinement type checking unsound
and restored soundness via a refinement type based termination checker.
%
Next, we presented Abstract~(Chapter~\ref{chapter:abstractrefinements}) 
and Bounded~(Chapter~\ref{boundedrefinements}) Refinement Types, 
that use uninterpreted functions to 
\textit{abstract} and \textit{bound} over the refinements of the types. 
We used both these techniques to encode higher order, modular specifications
while preserving SMT based decidable and predictable type checking. 
%
Finally, we presented Refinement Reflection (Chapter~\ref{refinementrflection})
a technique that reflects terminating, user defined, 
Haskell functions into the logic, 
turning (Liquid) Haskell into an arbitrarily expressive 
theorem prover. 
%
We used \toolname to prove correctness 
of sophisticated properties ranging from 
safe memory indexing to code equivalence over parallelization~(Chapter~\ref{stringmatcher})

In short, we described how to turn Haskell into a theorem prover
that enjoys both 
the SMT-based automatic and predictable type checking
of refinement types
and 
the optimized libraries and parallel runtimes of 
the mature, general purpose language Haskell.

In the future we plan to use \toolname as an interactive environment 
that, using techniques of code synthesis and error diagnosis, 
will integrate formal verification into the mainstream development process 
to aid, rather than complicate, code development.




